var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [QuantumHamiltonian]","category":"page"},{"location":"api/#QuantumHamiltonian.AbstractHilbertSpaceRepresentation","page":"API","title":"QuantumHamiltonian.AbstractHilbertSpaceRepresentation","text":"AbstractHilbertSpaceRepresentation{BR, S}\n\n\n\n\n\n","category":"type"},{"location":"api/#QuantumHamiltonian.AbstractOperator","page":"API","title":"QuantumHamiltonian.AbstractOperator","text":"AbstractOperator{S<:Number}\n\nRepresent an abstract operator in Hilbert space.\n\n\n\n\n\n","category":"type"},{"location":"api/#QuantumHamiltonian.AbstractOperatorRepresentation","page":"API","title":"QuantumHamiltonian.AbstractOperatorRepresentation","text":"AbstractOperatorRepresentation{S}\n\n\n\n\n\n","category":"type"},{"location":"api/#QuantumHamiltonian.DecomposedHilbertSpaceRepresentation","page":"API","title":"QuantumHamiltonian.DecomposedHilbertSpaceRepresentation","text":"DecomposedHilbertSpaceRepresentation\n\nRepresents the decomposed Hilbert space representation. i.e. subspace of the total Hilbert space, with basis states grouped by tags.\n\n\n\n\n\n","category":"type"},{"location":"api/#QuantumHamiltonian.DictIndexedVector","page":"API","title":"QuantumHamiltonian.DictIndexedVector","text":"\n\n\n\n","category":"type"},{"location":"api/#QuantumHamiltonian.GlobalBitFlip","page":"API","title":"QuantumHamiltonian.GlobalBitFlip","text":"GlobalBitFlip\n\nGlobal bit flip operation. For spin half systems, this amounts to ℤ₂ spin flip.\n\n\n\n\n\n","category":"type"},{"location":"api/#QuantumHamiltonian.HilbertSpace","page":"API","title":"QuantumHamiltonian.HilbertSpace","text":"HilbertSpace{QN, TS}\n\nAbstract Hilbert space with quantum number type QN.\n\nExamples\n\njulia> using QuantumHamiltonian\n\njulia> spin_site = Site([State(\"Up\", +1), State(\"Dn\", -1)]);\n\njulia> hs = HilbertSpace([spin_site, spin_site]);\n\n\n\n\n\n","category":"type"},{"location":"api/#QuantumHamiltonian.HilbertSpaceRepresentation","page":"API","title":"QuantumHamiltonian.HilbertSpaceRepresentation","text":"HilbertSpaceRepresentation{BR, HS, BasisType}\n\n\n\n\n\n","category":"type"},{"location":"api/#QuantumHamiltonian.HilbertSpaceSector","page":"API","title":"QuantumHamiltonian.HilbertSpaceSector","text":"HilbertSpaceSector{QN}\n\nHilbert space sector.\n\n\n\n\n\n","category":"type"},{"location":"api/#QuantumHamiltonian.IntegerModulo","page":"API","title":"QuantumHamiltonian.IntegerModulo","text":"IntegerModulo{N}\n\nImplement Zₙ.\n\n\n\n\n\n","category":"type"},{"location":"api/#QuantumHamiltonian.NullOperator","page":"API","title":"QuantumHamiltonian.NullOperator","text":"NullOperator\n\nA null operator, i.e. 0.\n\n\n\n\n\n","category":"type"},{"location":"api/#QuantumHamiltonian.OperatorRepresentation","page":"API","title":"QuantumHamiltonian.OperatorRepresentation","text":"OperatorRepresentation{HSR, S, O}\n\nOperator representation of given operator of type O.\n\n\n\n\n\n","category":"type"},{"location":"api/#QuantumHamiltonian.PureOperator","page":"API","title":"QuantumHamiltonian.PureOperator","text":"PureOperator{Scalar, BR}\n\nRepresents an operator α (P₁  P₂    Pₙ) where Pᵢ is either identity (when bitmask is set to zero), or projection rᵢcᵢ (when bitmask is set to one).\n\nSee also: pure_operator\n\nFields\n\nbitmask   :: BR\nbitrow    :: BR\nbitcol    :: BR\namplitude :: Scalar\n\n\n\n\n\n","category":"type"},{"location":"api/#QuantumHamiltonian.ReducedHilbertSpaceRepresentation","page":"API","title":"QuantumHamiltonian.ReducedHilbertSpaceRepresentation","text":"ReducedHilbertSpaceRepresentation{HSR, BR, C}\n\nRepresentation of the symmetry-reduced hilbert space. Currently only supports Translation group (i.e. Abelian group). ```\n\n\n\n\n\n","category":"type"},{"location":"api/#QuantumHamiltonian.ReducedOperatorRepresentation","page":"API","title":"QuantumHamiltonian.ReducedOperatorRepresentation","text":"ReducedOperatorRepresentation{RHSR, O, S, BR}\n\nRepresentation of an operator of type O in the symmetry-reduced hilbert space representation of type RHSR.\n\n\n\n\n\n","category":"type"},{"location":"api/#QuantumHamiltonian.Site","page":"API","title":"QuantumHamiltonian.Site","text":"Site{QN}\n\nA site with quantum number type QN.\n\nExamples\n\njulia> using QuantumHamiltonian\n\njulia> site = Site([State(\"Up\", 1), State(\"Dn\", -1)]);\n\n\n\n\n\n","category":"type"},{"location":"api/#QuantumHamiltonian.SortedIndexedVector","page":"API","title":"QuantumHamiltonian.SortedIndexedVector","text":"\n\n\n\n","category":"type"},{"location":"api/#QuantumHamiltonian.SparseState","page":"API","title":"QuantumHamiltonian.SparseState","text":"struct SparseState{Scalar<:Number, BR}\n\nRepresents a vector in unrestricted Hilbert space.\n\n\n\n\n\n","category":"type"},{"location":"api/#QuantumHamiltonian.SparseState-Union{Tuple{S}, Tuple{DT}, Tuple{HS}, Tuple{BR}, Tuple{HilbertSpaceRepresentation{BR, HS, DT}, AbstractVector{S}}, Tuple{HilbertSpaceRepresentation{BR, HS, DT}, AbstractVector{S}, Real}} where {BR, HS, DT, S<:Number}","page":"API","title":"QuantumHamiltonian.SparseState","text":"SparseState(hsrep, state_rep, tol=√eps(Float64))\n\nMake a SparseState from a representation\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.State","page":"API","title":"QuantumHamiltonian.State","text":"State{QN}\n\nState with quantum number type QN.\n\nExamples\n\njulia> using QuantumHamiltonian\n\njulia> up = State(\"Up\", 1)\nState{Tuple{Int64}}(\"Up\", (1,))\n\njulia> State(\"Dn\", (-1, 1))\nState{Tuple{Int64, Int64}}(\"Dn\", (-1, 1))\n\n\n\n\n\n","category":"type"},{"location":"api/#QuantumHamiltonian.SumOperator","page":"API","title":"QuantumHamiltonian.SumOperator","text":"SumOperator{Scalar, BR}\n\nRepresents a sum of pure operators.\n\nFields\n\nterms::Vector{PureOperator{Scalar,BR}}\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.valtype-Union{Tuple{Type{var\"#s179\"} where var\"#s179\"<:AbstractOperator{S}}, Tuple{S}} where S","page":"API","title":"Base.valtype","text":"valtype(lhs::Type{<:AbstractOperator{S}})\n\nReturns the valtype (scalar type) of the given AbstractOperator.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeTools.dimension-Tuple{HilbertSpaceRepresentation}","page":"API","title":"LatticeTools.dimension","text":"dimension\n\nDimension of the Concrete Hilbert space, i.e. number of basis vectors.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeTools.dimension-Tuple{ReducedHilbertSpaceRepresentation}","page":"API","title":"LatticeTools.dimension","text":"dimension(arg::ReducedHilbertSpaceRepresentation{HSR, BR, C}) -> Int\n\nDimension of the given reduced hilbert space representation, i.e. number of basis elements.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeTools.dimension-Tuple{Site}","page":"API","title":"LatticeTools.dimension","text":"dimension(site)\n\nHilbert space dimension of a given site (= number of states).\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeTools.numsites-Tuple{AbstractHilbertSpaceRepresentation, Vararg{Any, N} where N}","page":"API","title":"LatticeTools.numsites","text":"numsites(hsr::AbstractHilbertSpaceRepresentation, args...;kwargs...)\n\nCall numsites with basespace of hsr.\n\n\n\n\n\n","category":"method"},{"location":"api/#LatticeTools.numsites-Tuple{HilbertSpaceSector, Vararg{Any, N} where N}","page":"API","title":"LatticeTools.numsites","text":"numsites(hss::HilbertSpaceSector, args...;kwargs...)\n\nCall numsites with basespace of hss.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.apply!-Tuple{AbstractArray, AbstractArray, AbstractOperatorRepresentation}","page":"API","title":"QuantumHamiltonian.apply!","text":"apply!(out, opr, state)\n\nPerform out += opr * state. Apply the operator representation opr to the row vector state and add it to the row vector out. Return sum of errors and sum of error-squared. Call apply_serial! if Threads.nthreads() == 1, and apply_parallel! otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.apply!-Tuple{AbstractArray, AbstractOperatorRepresentation, AbstractArray}","page":"API","title":"QuantumHamiltonian.apply!","text":"apply!(out, opr, state)\n\nPerform out += opr * state. Apply the operator representation opr to the column vector state and add it to the column vector out. Return sum of errors and sum of error-squared. Call apply_serial! if Threads.nthreads() == 1, and apply_parallel! otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.apply!-Union{Tuple{BR}, Tuple{S2}, Tuple{S1}, Tuple{SparseState{S1, BR}, NullOperator, SparseState{S2, BR}}} where {S1, S2, BR}","page":"API","title":"QuantumHamiltonian.apply!","text":"apply!(out, nullop, psi)\n\nApply operator to psi and add it to out.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.apply_parallel!-Union{Tuple{S}, Tuple{AbstractMatrix{T} where T, AbstractMatrix{T} where T, AbstractOperatorRepresentation{S}}} where S","page":"API","title":"QuantumHamiltonian.apply_parallel!","text":"apply_parallel!(out, state, opr)\n\nPerform out += state * opr. Apply the operator representation opr to the matrix state, whose rows are vectors, and add it to the rows of the matrix out. Multi-threaded version.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.apply_parallel!-Union{Tuple{S}, Tuple{AbstractMatrix{T} where T, AbstractOperatorRepresentation{S}, AbstractMatrix{T} where T}} where S","page":"API","title":"QuantumHamiltonian.apply_parallel!","text":"apply_parallel!(out, opr, state)\n\nPerform out += opr * state. Apply the operator representation opr to  the matrix state, whose columns are vectors, and add it to the columns of the matrix out. Multi-threaded version.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.apply_parallel!-Union{Tuple{S}, Tuple{AbstractVector{T} where T, AbstractOperatorRepresentation{S}, AbstractVector{T} where T}} where S","page":"API","title":"QuantumHamiltonian.apply_parallel!","text":"apply_parallel!(out, opr, state)\n\nPerform out += opr * state. Apply the operator representation opr to the column vector state and add it to the column vector out. Multi-threaded version.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.apply_parallel!-Union{Tuple{S}, Tuple{AbstractVector{T} where T, AbstractVector{T} where T, AbstractOperatorRepresentation{S}}} where S","page":"API","title":"QuantumHamiltonian.apply_parallel!","text":"apply_parallel!(out, state, opr)\n\nPerform out += state * opr. Apply the operator representation opr to the row vector state and add it to the row vector out. Return sum of errors and sum of error-squared. Multi-threaded version.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.apply_serial!-Union{Tuple{S}, Tuple{AbstractMatrix{T} where T, AbstractMatrix{T} where T, AbstractOperatorRepresentation{S}}} where S","page":"API","title":"QuantumHamiltonian.apply_serial!","text":"apply_serial!(out, state, opr)\n\nPerform out += state * opr. Apply the operator representation opr to the matrix state, whose rows are vectors, and add it to the rows of the matrix out. Single-threaded version.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.apply_serial!-Union{Tuple{S}, Tuple{AbstractMatrix{T} where T, AbstractOperatorRepresentation{S}, AbstractMatrix{T} where T}} where S","page":"API","title":"QuantumHamiltonian.apply_serial!","text":"apply_serial!(out, opr, state)\n\nPerform out += opr * state. Apply the operator representation opr to  the matrix state, whose columns are vectors, and add it to the columns of the matrix out. Single-threaded version.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.apply_serial!-Union{Tuple{S}, Tuple{AbstractVector{T} where T, AbstractOperatorRepresentation{S}, AbstractVector{T} where T}} where S","page":"API","title":"QuantumHamiltonian.apply_serial!","text":"apply_serial!(out, opr, state)\n\nPerform out += opr * state. Apply the operator representation opr to the column vector state and add it to the column vector out. Single-threaded version.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.apply_serial!-Union{Tuple{S}, Tuple{AbstractVector{T} where T, AbstractVector{T} where T, AbstractOperatorRepresentation{S}}} where S","page":"API","title":"QuantumHamiltonian.apply_serial!","text":"apply_serial!(out, state, opr)\n\nPerform out += state * opr. Apply the operator representation opr to the row vector state and add it to the row vector out. Return sum of errors and sum of error-squared. Single-threaded version.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.basespace","page":"API","title":"QuantumHamiltonian.basespace","text":"basespace(x::AbstractHilbertSpaceRepresentation)\nbasespace(x::Type{T}) where {T<:AbstractHilbertSpaceRepresentation}\n\nIf the argument is an instance of AbstractHilbertSpaceRepresentation, return the underlying Hilbert space of the Hilbert space representation. If the argument is a subtype of AbstractHilbertSpaceRepresentation, return the type of the underlying Hilbert space. Subtypes of AbstractHilbertSpace must implement this method.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumHamiltonian.basespace-Tuple{HilbertSpaceSector, Vararg{Any, N} where N}","page":"API","title":"QuantumHamiltonian.basespace","text":"basespace(hss::HilbertSpaceSector, args...;kwargs...)\n\nCall basespace with basespace of hss.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.basespace-Tuple{HilbertSpace}","page":"API","title":"QuantumHamiltonian.basespace","text":"basespace(hs)\n\nGet the base space of the HilbertSpace hs, which is itself.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.bitoffset-Tuple{AbstractHilbertSpaceRepresentation, Vararg{Any, N} where N}","page":"API","title":"QuantumHamiltonian.bitoffset","text":"bitoffset(hsr::AbstractHilbertSpaceRepresentation, args...;kwargs...)\n\nCall bitoffset with basespace of hsr.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.bitoffset-Tuple{HilbertSpaceSector, Vararg{Any, N} where N}","page":"API","title":"QuantumHamiltonian.bitoffset","text":"bitoffset(hss::HilbertSpaceSector, args...;kwargs...)\n\nCall bitoffset with basespace of hss.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.bitwidth-Tuple{AbstractHilbertSpaceRepresentation, Vararg{Any, N} where N}","page":"API","title":"QuantumHamiltonian.bitwidth","text":"bitwidth(hsr::AbstractHilbertSpaceRepresentation, args...;kwargs...)\n\nCall bitwidth with basespace of hsr.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.bitwidth-Tuple{HilbertSpaceSector, Vararg{Any, N} where N}","page":"API","title":"QuantumHamiltonian.bitwidth","text":"bitwidth(hss::HilbertSpaceSector, args...;kwargs...)\n\nCall bitwidth with basespace of hss.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.bitwidth-Tuple{HilbertSpace}","page":"API","title":"QuantumHamiltonian.bitwidth","text":"bitwidth(hs, [isite])\n\nTotal number of bits\n\njulia> using QuantumHamiltonian\n\njulia> spin_site = Site([State(\"Up\", +1), State(\"Dn\", -1)]);\n\njulia> hs = HilbertSpace([spin_site, spin_site, spin_site,]);\n\njulia> bitwidth(hs)\n3\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.bitwidth-Tuple{Site}","page":"API","title":"QuantumHamiltonian.bitwidth","text":"bitwidth(site)\n\nNumber of bits necessary to represent the states of the given site.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.compress-Tuple{AbstractHilbertSpaceRepresentation, Vararg{Any, N} where N}","page":"API","title":"QuantumHamiltonian.compress","text":"compress(hsr::AbstractHilbertSpaceRepresentation, args...;kwargs...)\n\nCall compress with basespace of hsr.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.compress-Tuple{HilbertSpaceSector, Vararg{Any, N} where N}","page":"API","title":"QuantumHamiltonian.compress","text":"compress(hss::HilbertSpaceSector, args...;kwargs...)\n\nCall compress with basespace of hss.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.compress-Union{Tuple{BR}, Tuple{AbstractVector{var\"#s4\"} where var\"#s4\"<:Integer, AbstractVector{var\"#s1\"} where var\"#s1\"<:Integer, Type{BR}}} where BR<:Unsigned","page":"API","title":"QuantumHamiltonian.compress","text":"compress(bitwidths, data, BR)\n\nCompress data array into a binary integer of type BR.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.compress-Union{Tuple{BR}, Tuple{HilbertSpace, CartesianIndex}, Tuple{HilbertSpace, CartesianIndex, Type{BR}}} where BR<:Unsigned","page":"API","title":"QuantumHamiltonian.compress","text":"compress(hs, indexarray::CartesianIndex, binary_type=UInt)\n\nConvert a cartesian index (a of state) to its binary representation\n\nExamples\n\njulia> using QuantumHamiltonian\n\njulia> spin_site = Site([State(\"Up\", +1), State(\"Dn\", -1)]);\n\njulia> hs = HilbertSpace([spin_site, spin_site]);\n\njulia> compress(hs, CartesianIndex(2,2))\n0x0000000000000003\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.compress-Union{Tuple{BR}, Tuple{Site, Integer}, Tuple{Site, Integer, Type{BR}}} where BR<:Unsigned","page":"API","title":"QuantumHamiltonian.compress","text":"compress(site, state_index, binary_type=UInt) -> binary_type\n\nGet binary representation of the state specified by state_index. Check bounds 1 <= state_index <= dimension(site), and returns binary representation of state_index-1.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.extract-Tuple{AbstractHilbertSpaceRepresentation, Vararg{Any, N} where N}","page":"API","title":"QuantumHamiltonian.extract","text":"extract(hsr::AbstractHilbertSpaceRepresentation, args...;kwargs...)\n\nCall extract with basespace of hsr.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.extract-Tuple{HilbertSpaceSector, Vararg{Any, N} where N}","page":"API","title":"QuantumHamiltonian.extract","text":"extract(hss::HilbertSpaceSector, args...;kwargs...)\n\nCall extract with basespace of hss.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.extract-Union{Tuple{BR}, Tuple{HilbertSpace, BR}} where BR<:Unsigned","page":"API","title":"QuantumHamiltonian.extract","text":"extract(hs, binrep)\n\nConvert binary representation to an array of indices (of states)\n\nExamples\n\njulia> using QuantumHamiltonian\n\njulia> spin_site = Site([State(\"Up\", +1), State(\"Dn\", -1)]);\n\njulia> hs = HilbertSpace([spin_site, spin_site]);\n\njulia> extract(hs, 0x03)\nCartesianIndex(2, 2)\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.findindex","page":"API","title":"QuantumHamiltonian.findindex","text":"findindex(a::AbstractIndexedVector{E}, key::E)\n\nReturn the index of the element key if it exists in a. Otherwise return -1.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumHamiltonian.get_basis_index_amplitude","page":"API","title":"QuantumHamiltonian.get_basis_index_amplitude","text":"get_basis_index_amplitude(hsr::AbstractHilbertSpaceRepresentation, bin::Unsigned)\n\nReturn a tuple (index=index, amplitude=amplitude) that corresponds to the binary bin, i.e., the index of the basis state that overlaps with bin and the value of the overlap ⟨b|ϕᵢ⟩. Return (index=-1, amplitude=0) if bin is not in the representation. Subtypes of AbstractHilbertSpaceRepresentation must implement this method.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumHamiltonian.get_basis_index_amplitude-Tuple{HilbertSpaceRepresentation, Unsigned}","page":"API","title":"QuantumHamiltonian.get_basis_index_amplitude","text":"get_basis_index_amplitude(hsr, bvec)\n\nGet the index of the basis state that overlaps with bvec, and the value of the overlap. Currentiy it is guaranteed to be at most one. Returns (i, ⟨b|ϕᵢ⟩). For the unsymmetrized HilbertSpaceRepresentation, the amplitude is 1 of Int type. If no such basis vector exists, return (-1, 0).\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.get_basis_iterator","page":"API","title":"QuantumHamiltonian.get_basis_iterator","text":"get_basis_iterator(hsr::AbstractHilbertSpaceRepresentation)\n\nReturn an iterator of the list of basis binaries. Subtypes of AbstractHilbertSpaceRepresentation must implement this method.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumHamiltonian.get_basis_list","page":"API","title":"QuantumHamiltonian.get_basis_list","text":"get_basis_list(hsr::AbstractHilbertSpaceRepresentation)\n\nReturn a Vector of the list of basis binaries. Subtypes of AbstractHilbertSpaceRepresentation must implement this method.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumHamiltonian.get_basis_state","page":"API","title":"QuantumHamiltonian.get_basis_state","text":"get_basis_state(hsr::AbstractHilbertSpaceRepresentation, index::Integer)\n\nReturn the state at index index. Subtypes of AbstractHilbertSpaceRepresentation must implement this method.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumHamiltonian.get_basis_state-Tuple{HilbertSpaceRepresentation, Integer}","page":"API","title":"QuantumHamiltonian.get_basis_state","text":"get_basis_state(hsr, index)\n\nGet the basis state representation at index.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.get_bitmask-Tuple{AbstractHilbertSpaceRepresentation, Vararg{Any, N} where N}","page":"API","title":"QuantumHamiltonian.get_bitmask","text":"get_bitmask(hsr::AbstractHilbertSpaceRepresentation, args...;kwargs...)\n\nCall get_bitmask with basespace of hsr.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.get_column_iterator-Tuple{NullOperator, Unsigned}","page":"API","title":"QuantumHamiltonian.get_column_iterator","text":"get_column_iterator(op, bcol)\n\nReturns an iterator over the elements of the column corresponding to bit representation bc.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.get_column_iterator-Tuple{OperatorRepresentation, Integer}","page":"API","title":"QuantumHamiltonian.get_column_iterator","text":"get_column_iterator(opr, icol)\n\nReturns an iterator which generates a list of elements of the column icol. Each element is represented as (irow, amplitude). May contain duplicates and invalid elements. Invalid elements are represented as (-1, amplitude).\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.get_element-Tuple{OperatorRepresentation, Integer, Integer}","page":"API","title":"QuantumHamiltonian.get_element","text":"get_element(opr, irow, icol)\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.get_operator","page":"API","title":"QuantumHamiltonian.get_operator","text":"get_operator(x::AbstractOperatorRepresentation)\n\nReturn the operator of the operator representation. Subclass of AbstractOperatorRepresentation must define this method.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumHamiltonian.get_quantum_number-Tuple{AbstractHilbertSpaceRepresentation, Vararg{Any, N} where N}","page":"API","title":"QuantumHamiltonian.get_quantum_number","text":"get_quantum_number(hsr::AbstractHilbertSpaceRepresentation, args...;kwargs...)\n\nCall get_quantum_number with basespace of hsr.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.get_quantum_number-Tuple{HilbertSpace, Unsigned}","page":"API","title":"QuantumHamiltonian.get_quantum_number","text":"get_quantum_number(hs, rep)\n\nGet the quantum number of rep, which is either a binary representation, or a CartesianIndex.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.get_quantum_number-Tuple{HilbertSpaceSector, Vararg{Any, N} where N}","page":"API","title":"QuantumHamiltonian.get_quantum_number","text":"get_quantum_number(hss::HilbertSpaceSector, args...;kwargs...)\n\nCall get_quantum_number with basespace of hss.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.get_quantum_number-Union{Tuple{QN}, Tuple{Site{QN}, Integer}} where QN","page":"API","title":"QuantumHamiltonian.get_quantum_number","text":"get_quantum_number(site, state_index)\n\nGets the quantum number of state specified by state_index.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.get_quantum_numbers-Union{Tuple{HilbertSpace{QN}}, Tuple{QN}} where QN","page":"API","title":"QuantumHamiltonian.get_quantum_numbers","text":"get_quantum_numbers(hs)\n\nReturn a sorted list of quantum numbers of the hilbert space hs.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.get_row_iterator-Tuple{NullOperator, Unsigned}","page":"API","title":"QuantumHamiltonian.get_row_iterator","text":"get_row_iterator(op, br)\n\nReturns an iterator over the elements of the row corresponding to bit representation br.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.get_row_iterator-Tuple{OperatorRepresentation, Integer}","page":"API","title":"QuantumHamiltonian.get_row_iterator","text":"get_row_iterator(opr, irow)\n\nReturns an iterator which generates a list of elements of the row irow. Each element is represented as (icol, amplitude). May contain duplicates and invalid elements. Invalid elements are represented as (-1, amplitude).\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.get_row_iterator-Union{Tuple{BR}, Tuple{S}, Tuple{O}, Tuple{RHSR}, Tuple{ReducedOperatorRepresentation{RHSR, O, S, BR}, Integer}} where {RHSR, O, S, BR}","page":"API","title":"QuantumHamiltonian.get_row_iterator","text":"get_row_iterator(ropr::ROR, irow_r::Integer)\n\nGet the row iterator for the reduced operator representation\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.get_site-Tuple{AbstractHilbertSpaceRepresentation, Vararg{Any, N} where N}","page":"API","title":"QuantumHamiltonian.get_site","text":"get_site(hsr::AbstractHilbertSpaceRepresentation, args...;kwargs...)\n\nCall get_site with basespace of hsr.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.get_site-Tuple{HilbertSpaceSector, Vararg{Any, N} where N}","page":"API","title":"QuantumHamiltonian.get_site","text":"get_site(hss::HilbertSpaceSector, args...;kwargs...)\n\nCall get_site with basespace of hss.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.get_space","page":"API","title":"QuantumHamiltonian.get_space","text":"get_space(x::AbstractOperatorRepresentation)\n\nReturn the Hilbert Space representation on which the operator representation is defined. Subclass of AbstractOperatorRepresentation must define this method.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumHamiltonian.get_state-Tuple{AbstractHilbertSpaceRepresentation, Vararg{Any, N} where N}","page":"API","title":"QuantumHamiltonian.get_state","text":"get_state(hsr::AbstractHilbertSpaceRepresentation, args...;kwargs...)\n\nCall get_state with basespace of hsr.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.get_state-Union{Tuple{BR}, Tuple{AbstractHilbertSpace, BR, Integer}} where BR<:Unsigned","page":"API","title":"QuantumHamiltonian.get_state","text":"get_state(hs, binrep, isite)\n\nGet the local state at site isite for the basis state represented by binrep. Returns an object of type State\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.get_state-Union{Tuple{U}, Tuple{Site, U}} where U<:Unsigned","page":"API","title":"QuantumHamiltonian.get_state","text":"get_state(site, binrep) where {QN, BR<:Unsigned}\n\nReturns the state of site represented by the bits binrep.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.get_state_index-Tuple{AbstractHilbertSpaceRepresentation, Vararg{Any, N} where N}","page":"API","title":"QuantumHamiltonian.get_state_index","text":"get_state_index(hsr::AbstractHilbertSpaceRepresentation, args...;kwargs...)\n\nCall get_state_index with basespace of hsr.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.get_state_index-Union{Tuple{BR}, Tuple{AbstractHilbertSpace, BR, Integer}} where BR<:Unsigned","page":"API","title":"QuantumHamiltonian.get_state_index","text":"get_state_index(hs, binrep, isite)\n\nGet the index of the local state at site isite for the basis state represented by binrep.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.get_state_index-Union{Tuple{U}, Tuple{Site, U}} where U<:Unsigned","page":"API","title":"QuantumHamiltonian.get_state_index","text":"get_state_index(site, binrep)\n\nGets the state index of the binary representation. Returns Int(binrep+1).\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.get_tag-Tuple{AbstractHilbertSpaceRepresentation, Vararg{Any, N} where N}","page":"API","title":"QuantumHamiltonian.get_tag","text":"get_tag(hsr::AbstractHilbertSpaceRepresentation, args...;kwargs...)\n\nCall get_tag with basespace of hsr.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.get_tag-Tuple{HilbertSpaceSector, Vararg{Any, N} where N}","page":"API","title":"QuantumHamiltonian.get_tag","text":"get_tag(hss::HilbertSpaceSector, args...;kwargs...)\n\nCall get_tag with basespace of hss.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.hs_get_basis_list-Union{Tuple{BR}, Tuple{QN}, Tuple{AbstractHilbertSpace{QN}, AbstractVector{QN}}, Tuple{AbstractHilbertSpace{QN}, AbstractVector{QN}, Type{BR}}} where {QN, BR<:Unsigned}","page":"API","title":"QuantumHamiltonian.hs_get_basis_list","text":"hs_get_basis_list(hs, allowed_quantum_numbers, binary_type=UInt)\n\nGenerate a basis for the HilbertSpaceSector.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.hs_get_basis_list-Union{Tuple{HilbertSpaceSector{QN, HS}}, Tuple{BR}, Tuple{HS}, Tuple{QN}, Tuple{HilbertSpaceSector{QN, HS}, Type{BR}}} where {QN, HS, BR<:Unsigned}","page":"API","title":"QuantumHamiltonian.hs_get_basis_list","text":"hs_get_basis_list(hss, binary_type=UInt)\n\nGenerate a basis for the HilbertSpaceSector.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.operatortype","page":"API","title":"QuantumHamiltonian.operatortype","text":"operatortype(x::AbstractOperatorRepresentation)\n\nReturn the type of the operator of the operator representation. Subclass of AbstractOperatorRepresentation must define this method.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumHamiltonian.pure_operator-Union{Tuple{BR}, Tuple{S}, Tuple{HilbertSpace, Integer, Integer, Integer}, Tuple{HilbertSpace, Integer, Integer, Integer, S}, Tuple{HilbertSpace, Integer, Integer, Integer, S, Type{BR}}} where {S<:Number, BR<:Unsigned}","page":"API","title":"QuantumHamiltonian.pure_operator","text":"pure_operator(hilbert_space, isite, istate_row, istate_col, amplitude=1, [binary_type=UInt])\n\nCreates a pure operator where projection is at one of the sites.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.qntype-Tuple{AbstractHilbertSpaceRepresentation, Vararg{Any, N} where N}","page":"API","title":"QuantumHamiltonian.qntype","text":"qntype(hsr::AbstractHilbertSpaceRepresentation, args...;kwargs...)\n\nCall qntype with basespace of hsr.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.qntype-Union{Tuple{Type{var\"#s155\"} where var\"#s155\"<:HilbertSpaceSector{QN, HS}}, Tuple{HS}, Tuple{QN}} where {QN, HS}","page":"API","title":"QuantumHamiltonian.qntype","text":"qntype(arg::Type{HilbertSpaceSector{QN}})\n\nReturns the quantum number type of the given hilbert space sector type.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.qntype-Union{Tuple{Type{var\"#s6\"} where var\"#s6\"<:State{QN}}, Tuple{QN}} where QN","page":"API","title":"QuantumHamiltonian.qntype","text":"qntype(::Type{State{QN}})\n\nReturns the quantum number type of the given state type.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.quantum_number_sectors-Union{Tuple{Site{QN}}, Tuple{QN}} where QN","page":"API","title":"QuantumHamiltonian.quantum_number_sectors","text":"quantum_number_sectors(site) -> Vector{QN}\n\nGets a list of possible quantum numbers as a sorted vector of QN.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.represent-Union{Tuple{AbstractHilbertSpace}, Tuple{BT}, Tuple{BR}, Tuple{AbstractHilbertSpace, Type{BR}}, Tuple{AbstractHilbertSpace, Type{BR}, Type{BT}}} where {BR<:Unsigned, BT<:AbstractIndexedVector}","page":"API","title":"QuantumHamiltonian.represent","text":"represent(hs, binary_type=UInt, basis_type=SortedIndexedVector)\n\nMake a HilbertSpaceRepresentation with all the basis vectors of the specified HilbertSpace. This function defaults to represent_array.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.represent-Union{Tuple{BT}, Tuple{BR}, Tuple{AbstractHilbertSpace, AbstractVector{BR}}, Tuple{AbstractHilbertSpace, AbstractVector{BR}, Type{BT}}} where {BR<:Unsigned, BT<:AbstractIndexedVector}","page":"API","title":"QuantumHamiltonian.represent","text":"represent(hs, basis_list, basis_type=SortedIndexedVector)\n\nMake a HilbertSpaceRepresentation with the provided list of basis vectors. This defaults to represent_array.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.represent-Union{Tuple{O}, Tuple{HSR}, Tuple{HSR, O}} where {HSR<:HilbertSpaceRepresentation, O<:AbstractOperator}","page":"API","title":"QuantumHamiltonian.represent","text":"represent(hilbert_space_representation, operator)\n\nCreate an OperatorRepresentation of the operator in the hilbert_space_representation.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.represent_array-Union{Tuple{AbstractHilbertSpace}, Tuple{BR}, Tuple{AbstractHilbertSpace, Type{BR}}} where BR<:Unsigned","page":"API","title":"QuantumHamiltonian.represent_array","text":"represent_array(hs, binary_type=UInt)\n\nMake a HilbertSpaceRepresentation with all the basis vectors of the specified HilbertSpace using FrozenSortedArrayIndex.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.represent_array-Union{Tuple{BR}, Tuple{AbstractHilbertSpace, AbstractVector{BR}}} where BR<:Unsigned","page":"API","title":"QuantumHamiltonian.represent_array","text":"represent_array(hs, basis_list)\n\nMake a HilbertSpaceRepresentation with the provided list of basis vectors using FrozenSortedArrayIndex.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.represent_dict-Union{Tuple{AbstractHilbertSpace}, Tuple{BR}, Tuple{AbstractHilbertSpace, Type{BR}}} where BR<:Unsigned","page":"API","title":"QuantumHamiltonian.represent_dict","text":"represent_dict(hs, binary_type=UInt)\n\nMake a HilbertSpaceRepresentation with the provided list of basis vectors using Dict{binary_type, Int}.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.represent_dict-Union{Tuple{BR}, Tuple{AbstractHilbertSpace, AbstractVector{BR}}} where BR<:Unsigned","page":"API","title":"QuantumHamiltonian.represent_dict","text":"represent_dict(hs, basis_list)\n\nMake a HilbertSpaceRepresentation with the provided list of basis vectors using Dict.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.scalartype-Union{Tuple{SparseState{Scalar, BR}}, Tuple{BR}, Tuple{Scalar}} where {Scalar, BR}","page":"API","title":"QuantumHamiltonian.scalartype","text":"scalartype([state or type of state])\n\nReturn the scalar type of the state.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.scalartype-Union{Tuple{Type{var\"#s179\"} where var\"#s179\"<:AbstractOperator{S}}, Tuple{S}} where S","page":"API","title":"QuantumHamiltonian.scalartype","text":"scalartype(lhs::Type{<:AbstractOperator{S}})\n\nReturns the scalar type of the given AbstractOperator.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.sectorslice-Union{Tuple{TT}, Tuple{TS}, Tuple{HSR}, Tuple{HS}, Tuple{S}, Tuple{BR}, Tuple{DecomposedHilbertSpaceRepresentation{BR, S, HS, HSR, TS, TT}, AbstractVector{TT}}} where {BR, S, HS, HSR, TS, TT}","page":"API","title":"QuantumHamiltonian.sectorslice","text":"Predicate on the tags\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.sectorslice-Union{Tuple{TT}, Tuple{TS}, Tuple{HSR}, Tuple{HS}, Tuple{S}, Tuple{BR}, Tuple{DecomposedHilbertSpaceRepresentation{BR, S, HS, HSR, TS, TT}, Function}} where {BR, S, HS, HSR, TS, TT}","page":"API","title":"QuantumHamiltonian.sectorslice","text":"Predicate on the tags\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.simplify-Tuple{NullOperator}","page":"API","title":"QuantumHamiltonian.simplify","text":"simplify\n\nSimplify the given operator.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.spacetype","page":"API","title":"QuantumHamiltonian.spacetype","text":"spacetype(x::AbstractOperatorRepresentation)\nspacetype(x::Type{T}) where {T<:AbstractOperatorRepresentation}\n\nReturn the type of the Hilbert space representation on which the operator representation is defined. Subclass of AbstractOperatorRepresentation must define this method.\n\n\n\n\n\n","category":"function"},{"location":"api/#QuantumHamiltonian.splitblock-Tuple{Integer, Integer}","page":"API","title":"QuantumHamiltonian.splitblock","text":"splitblock\n\nSplit n into b blocks.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.splitrange-Tuple{AbstractVector{var\"#s6\"} where var\"#s6\"<:Integer, Integer}","page":"API","title":"QuantumHamiltonian.splitrange","text":"splitrange\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.symmetry_reduce!-Union{Tuple{So}, Tuple{Si}, Tuple{C}, Tuple{BR}, Tuple{HSR}, Tuple{AbstractVector{So}, ReducedHilbertSpaceRepresentation{HSR, BR, C, IV} where IV<:AbstractIndexedVector{BR}, AbstractVector{Si}}} where {HSR, BR, C, Si<:Number, So<:Number}","page":"API","title":"QuantumHamiltonian.symmetry_reduce!","text":"symmetry_reduce!(out, rhsr, largevector)\n\nAdds and not overwrites.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.symmetry_reduce-Union{Tuple{Si}, Tuple{C}, Tuple{BR}, Tuple{HSR}, Tuple{ReducedHilbertSpaceRepresentation{HSR, BR, C, IV} where IV<:AbstractIndexedVector{BR}, AbstractVector{Si}}} where {HSR, BR, C, Si<:Number}","page":"API","title":"QuantumHamiltonian.symmetry_reduce","text":"symmetry_reduce(rhsr, large_vector)\n\nReduce a large vector into the reduced hilbert space representation. Simply throw away components that don't fit.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.symmetry_reduce-Union{Tuple{S}, Tuple{SI}, Tuple{O}, Tuple{BR}, Tuple{AbstractHilbertSpace, AbstractArray{O, N} where N, AbstractArray{SI, N} where N, BR}, Tuple{AbstractHilbertSpace, AbstractArray{O, N} where N, AbstractArray{SI, N} where N, BR, Type{S}}} where {BR<:Unsigned, O, SI<:Number, S<:Number}","page":"API","title":"QuantumHamiltonian.symmetry_reduce","text":"symmetry_reduce(hsr, symops, amplitudes, bvec; tol=√ϵ)\n\nReturns bᵢ => ⟨B|ϕᵢ⟩, i.e., the basis state (represented by bᵢ, and the amount of that basis state that overlaps with the input. Returns the same amplitude as the get_basis_index_amplitude of the reduced Hilbert space representation\n\nBasis states: |ϕᵢ⟩ with a representative bᵢ input       : |B⟩\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.tagtype-Tuple{AbstractHilbertSpaceRepresentation, Vararg{Any, N} where N}","page":"API","title":"QuantumHamiltonian.tagtype","text":"tagtype(hsr::AbstractHilbertSpaceRepresentation, args...;kwargs...)\n\nCall tagtype with basespace of hsr.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.uncompress-Tuple{AbstractHilbertSpaceRepresentation, Vararg{Any, N} where N}","page":"API","title":"QuantumHamiltonian.uncompress","text":"uncompress(hsr::AbstractHilbertSpaceRepresentation, args...;kwargs...)\n\nCall uncompress with basespace of hsr.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.uncompress-Union{Tuple{BR}, Tuple{HilbertSpace, BR}} where BR<:Unsigned","page":"API","title":"QuantumHamiltonian.uncompress","text":"uncompress(hs, binrep)\n\nConvert binary representation to an array of indices (of states)\n\nExamples\n\njulia> using QuantumHamiltonian\n\njulia> spin_site = Site([State(\"Up\", +1), State(\"Dn\", -1)]);\n\njulia> hs = HilbertSpace([spin_site, spin_site]);\n\njulia> extract(hs, 0x03)\nCartesianIndex(2, 2)\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.update-Tuple{AbstractHilbertSpaceRepresentation, Vararg{Any, N} where N}","page":"API","title":"QuantumHamiltonian.update","text":"update(hsr::AbstractHilbertSpaceRepresentation, args...;kwargs...)\n\nCall update with basespace of hsr.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumHamiltonian.update-Union{Tuple{BR}, Tuple{AbstractHilbertSpace, BR, Integer, Integer}} where BR<:Unsigned","page":"API","title":"QuantumHamiltonian.update","text":"update(hs, binrep, isite, new_state_index)\n\nUpdate the binary representation of a basis state by changing the state at site isite to a new local state specified by new_state_index.\n\n\n\n\n\n","category":"method"},{"location":"hilbertspace/#Hilbert-space","page":"Hilbert space","title":"Hilbert space","text":"","category":"section"},{"location":"hilbertspace/#Site","page":"Hilbert space","title":"Site","text":"","category":"section"},{"location":"hilbertspace/","page":"Hilbert space","title":"Hilbert space","text":"The definition of a quantum many-body problem starts by defining the Hilbert space. The Site serves as a unit Hilbert space, and the Hilbert space for whole system can be constructed by taking the tensor product of them.","category":"page"},{"location":"hilbertspace/","page":"Hilbert space","title":"Hilbert space","text":"A Site can be constructed out of a set of State. For example,","category":"page"},{"location":"hilbertspace/","page":"Hilbert space","title":"Hilbert space","text":"julia> spinsite = Site([State(\"Up\", 1), State(\"Dn\", -1)])\nSite{Tuple{Int64}}(State{Tuple{Int64}}[State{Tuple{Int64}}(\"Up\", (1,)), State{Tuple{Int64}}(\"Dn\", (-1,))])","category":"page"},{"location":"hilbertspace/","page":"Hilbert space","title":"Hilbert space","text":"constructs a two-state site with spin-half degrees of freedom. The type parameter Tuple{Int} represents the type of Abelian quantum number. which is is 2S_z in this case. When there are more than one conserved quantum numbers, they can be combined: e.g. Tuple{Int, Int}, to represent the charge and total S_z, for example. Each basis vector is represented as a binary number, corresponding to their order in the constructor (0-based). For the example above, the up-state is represented as 0 and the down-state is represented as 1.","category":"page"},{"location":"hilbertspace/#HilbertSpace","page":"Hilbert space","title":"HilbertSpace","text":"","category":"section"},{"location":"hilbertspace/","page":"Hilbert space","title":"Hilbert space","text":"We can combine multiple sites to form a HilbertSpace. To construct a Hilbert space from the spin-half sites as defined above,","category":"page"},{"location":"hilbertspace/","page":"Hilbert space","title":"Hilbert space","text":"hilbert_space = HilbertSpace([spinsite, spinsite, spinsite, spinsite])","category":"page"},{"location":"hilbertspace/","page":"Hilbert space","title":"Hilbert space","text":"Note that all the basis vectors of the Hilbert space will be represented as a binary number, where each Site occupies a fixed location and width. e.g.","category":"page"},{"location":"hilbertspace/","page":"Hilbert space","title":"Hilbert space","text":"|↑↑↑↑⟩ = |0000⟩\n|↑↑↑↓⟩ = |0001⟩\n|↑↑↓↑⟩ = |0010⟩\n       ⋮\n|↓↓↓↓⟩ = |1111⟩","category":"page"},{"location":"hilbertspace/","page":"Hilbert space","title":"Hilbert space","text":"The number of bits assigned for each site is determined by Int(ceil(log2(length(site.states))), and can be accessed by bitwidth.","category":"page"},{"location":"representation/#Representation","page":"Representation","title":"Representation","text":"","category":"section"},{"location":"representation/#HilbertSpaceRepresentation","page":"Representation","title":"HilbertSpaceRepresentation","text":"","category":"section"},{"location":"representation/","page":"Representation","title":"Representation","text":"A HilbertSpaceRepresentation is a representation of the Hilbert space, with the list of basis vectors in a ascending order of their binary representations, and a lookup table for them. The HilbertSpaceRepresentation can be constructed using represent_array which uses FrozenSortedArrayIndex for the lookup table, or represent_dict which uses Dict.","category":"page"},{"location":"representation/","page":"Representation","title":"Representation","text":"represent(::HilbertSpace)\nrepresent_array(::HilbertSpace)\nrepresent_dict(::HilbertSpace)","category":"page"},{"location":"representation/#QuantumHamiltonian.represent-Tuple{HilbertSpace}","page":"Representation","title":"QuantumHamiltonian.represent","text":"represent(hs, binary_type=UInt, basis_type=SortedIndexedVector)\n\nMake a HilbertSpaceRepresentation with all the basis vectors of the specified HilbertSpace. This function defaults to represent_array.\n\n\n\n\n\n","category":"method"},{"location":"representation/#QuantumHamiltonian.represent_array-Tuple{HilbertSpace}","page":"Representation","title":"QuantumHamiltonian.represent_array","text":"represent_array(hs, binary_type=UInt)\n\nMake a HilbertSpaceRepresentation with all the basis vectors of the specified HilbertSpace using FrozenSortedArrayIndex.\n\n\n\n\n\n","category":"method"},{"location":"representation/#QuantumHamiltonian.represent_dict-Tuple{HilbertSpace}","page":"Representation","title":"QuantumHamiltonian.represent_dict","text":"represent_dict(hs, binary_type=UInt)\n\nMake a HilbertSpaceRepresentation with the provided list of basis vectors using Dict{binary_type, Int}.\n\n\n\n\n\n","category":"method"},{"location":"representation/","page":"Representation","title":"Representation","text":"You can also explicitly supply a list of basis vectors","category":"page"},{"location":"representation/","page":"Representation","title":"Representation","text":"represent(::HilbertSpace,::Vector{UInt})\nrepresent_array(::HilbertSpace,::Vector{UInt})\nrepresent_dict(::HilbertSpace,::Vector{UInt})","category":"page"},{"location":"representation/#QuantumHamiltonian.represent-Tuple{HilbertSpace, Vector{UInt64}}","page":"Representation","title":"QuantumHamiltonian.represent","text":"represent(hs, basis_list, basis_type=SortedIndexedVector)\n\nMake a HilbertSpaceRepresentation with the provided list of basis vectors. This defaults to represent_array.\n\n\n\n\n\n","category":"method"},{"location":"representation/#QuantumHamiltonian.represent_array-Tuple{HilbertSpace, Vector{UInt64}}","page":"Representation","title":"QuantumHamiltonian.represent_array","text":"represent_array(hs, basis_list)\n\nMake a HilbertSpaceRepresentation with the provided list of basis vectors using FrozenSortedArrayIndex.\n\n\n\n\n\n","category":"method"},{"location":"representation/#QuantumHamiltonian.represent_dict-Tuple{HilbertSpace, Vector{UInt64}}","page":"Representation","title":"QuantumHamiltonian.represent_dict","text":"represent_dict(hs, basis_list)\n\nMake a HilbertSpaceRepresentation with the provided list of basis vectors using Dict.\n\n\n\n\n\n","category":"method"},{"location":"representation/#OperatorRepresentation","page":"Representation","title":"OperatorRepresentation","text":"","category":"section"},{"location":"representation/","page":"Representation","title":"Representation","text":"An OperatorRepresentation is a representation of an operator in the given Hilbert space representation.","category":"page"},{"location":"representation/","page":"Representation","title":"Representation","text":"represent(::HilbertSpaceRepresentation,::AbstractOperator)","category":"page"},{"location":"representation/#QuantumHamiltonian.represent-Tuple{HilbertSpaceRepresentation, AbstractOperator}","page":"Representation","title":"QuantumHamiltonian.represent","text":"represent(hilbert_space_representation, operator)\n\nCreate an OperatorRepresentation of the operator in the hilbert_space_representation.\n\n\n\n\n\n","category":"method"},{"location":"symmetry/#Symmetry","page":"Symmetry","title":"Symmetry","text":"","category":"section"},{"location":"symmetry/#ReducedHilbertSpaceRepresentation","page":"Symmetry","title":"ReducedHilbertSpaceRepresentation","text":"","category":"section"},{"location":"symmetry/#ReducedOperatorRepresentation","page":"Symmetry","title":"ReducedOperatorRepresentation","text":"","category":"section"},{"location":"operator/#Operator","page":"Operator","title":"Operator","text":"","category":"section"},{"location":"operator/","page":"Operator","title":"Operator","text":"QuantumHamiltonian.jl uses operators in the \"projector\" representation.","category":"page"},{"location":"operator/#Operator-Types","page":"Operator","title":"Operator Types","text":"","category":"section"},{"location":"operator/#NullOperator","page":"Operator","title":"NullOperator","text":"","category":"section"},{"location":"operator/","page":"Operator","title":"Operator","text":"A NullOperator, as the name suggests, represents a null operator. It contains no fields, and is thus a singleton.","category":"page"},{"location":"operator/#PureOperator","page":"Operator","title":"PureOperator","text":"","category":"section"},{"location":"operator/","page":"Operator","title":"Operator","text":"A PureOperator represents an operator of the following form:","category":"page"},{"location":"operator/","page":"Operator","title":"Operator","text":"hatO = alpha hatP_1 otimes hatP_2 otimes ldots otimes hatP_N","category":"page"},{"location":"operator/","page":"Operator","title":"Operator","text":"where alpha is a complex number, and hatP_i is either identity, or projection rᵢcᵢ. It serves as a building block for all the operators used for the construction of the representation of the operators.","category":"page"},{"location":"operator/","page":"Operator","title":"Operator","text":"Internally, PureOperator has fields bitmask, bitrow, bitcol, and amplitude. The bitmask marks whether the hatP_i is identity or projection: If the bitmask for site i is unset, then hatP_i is an identity operator; if it is set, then hatP_i is a projection. The fields bitrow and bitcol can contain information on rᵢ and cᵢ: They can contain nonzero bit-field only at sites with nonzero bitmask.","category":"page"},{"location":"operator/#SumOperator","page":"Operator","title":"SumOperator","text":"","category":"section"},{"location":"operator/","page":"Operator","title":"Operator","text":"A SumOperator represents a sum of PureOperator. The scalar types of the PureOperators are required to be the same. While a SumOperator can be constructed from the PureOperators, it can also be constructed using additions/subtractions (See Binary Operations).","category":"page"},{"location":"operator/#Mathematical-Operations-for-Operators","page":"Operator","title":"Mathematical Operations for Operators","text":"","category":"section"},{"location":"operator/#Unary-Operations","page":"Operator","title":"Unary Operations","text":"","category":"section"},{"location":"operator/","page":"Operator","title":"Operator","text":"Unary operations + and - are defined for the operators. These simply act on the overall amplitude of the operators. + does not do anything and simply returns the original operator, while - changes sign only. The type of the resulting operator, is therefore the same as the original operator. There is one exception: when acting - on an operator whose scalar type is Bool, the resulting type has scalar type Int.","category":"page"},{"location":"operator/","page":"Operator","title":"Operator","text":"In addition to + and -, functions real and imag are also defined for the operators. Depending on the scalar type, the resulting operator has a different type:","category":"page"},{"location":"operator/","page":"Operator","title":"Operator","text":". N PR PC SR SC\nreal N PR PR SR SR\nimag N N PR N SR","category":"page"},{"location":"operator/","page":"Operator","title":"Operator","text":"N: NullOperator\nPR: PureOperator with real scalar type\nPC: PureOperator with complex scalar type\nSR: SumOperator with real scalar type\nSC: SumOperator with complex scalar type","category":"page"},{"location":"operator/#Binary-Operations","page":"Operator","title":"Binary Operations","text":"","category":"section"},{"location":"operator/","page":"Operator","title":"Operator","text":"Binary operations are also defined for the operators. Since PureOperators are closed under multiplication, while product of NullOperator and any operator is always NullOperator, we get the following multiplication table","category":"page"},{"location":"operator/","page":"Operator","title":"Operator","text":"* N P S\nN N N N\nP N P S\nS N S S","category":"page"},{"location":"operator/","page":"Operator","title":"Operator","text":"N: NullOperator, P: PureOperator, S: SumOperator","category":"page"},{"location":"operator/","page":"Operator","title":"Operator","text":"Additions or subtractions of two PureOperators, on the other hand, produce SumOperators","category":"page"},{"location":"operator/","page":"Operator","title":"Operator","text":"+/- N P S\nN N P S\nP P S S\nS S S S","category":"page"},{"location":"links/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"links/#Types","page":"Index","title":"Types","text":"","category":"section"},{"location":"links/","page":"Index","title":"Index","text":"Order = [:type]","category":"page"},{"location":"links/#Functions","page":"Index","title":"Functions","text":"","category":"section"},{"location":"links/","page":"Index","title":"Index","text":"Order = [:function]","category":"page"},{"location":"examples/spinhalf/#Example-1:-S1/2-Heisenberg-Chain","page":"Example 1: S=1/2 Heisenberg Chain","title":"Example 1: S=1/2 Heisenberg Chain","text":"","category":"section"},{"location":"examples/spinhalf/","page":"Example 1: S=1/2 Heisenberg Chain","title":"Example 1: S=1/2 Heisenberg Chain","text":"using SparseArrays\nusing LinearAlgebra\nusing Arpack\n# using Plots\n\nusing LatticeTools\nusing QuantumHamiltonian\n\nprintln(\"# S=1/2 Heisenberg Chain\")\nn_sites = 8;\n(hs, σ) = QuantumHamiltonian.Toolkit.spin_half_system(n_sites)\nprintln(\"Quantum number sectors (2Sz) : \", quantum_number_sectors(hs))\n\nS = Dict(μ => sum(σ(i, μ) for i in 1:n_sites) for μ in [:x, :y, :z])\nspin_squared = simplify(S[:x]^2 + S[:y]^2 + S[:z]^2)\nj1 = simplify(sum(σ(i, j) * σ(mod(i, n_sites)+1 , j) for i in 1:n_sites for j in [:x, :y, :z]))\nhs_rep = represent(hs);     # Use FrozenSortedArrayIndex{UInt} for basis lookup\n\nprintln(\"## All sectors at once\")\n# plt = plot(size=(400, 400))\nbegin\n  j1_rep = represent(hs_rep, j1)\n  eigenvalues, eigenvectors = eigs(j1_rep; nev=32, which=:SR, )\n  eigenvalues = real.(eigenvalues)\n  println(\"E : \", eigenvalues[1:5])\n  # scatter!(plt,\n  #          zeros(size(eigenvalues)), eigenvalues,\n  #          markershape=:hline,\n  #          markersize=10,\n  #          markerstrokecolor=:red,\n  #          legend=:none)\nend\n\nprintln(\"## Sz=0, each momentum sectors\")\nhs_sector = HilbertSpaceSector(hs, 0)\nhs_rep = represent_dict(hs_sector) # Use Dict{UInt, Int} for basis lookup\n\nunitcell = makeunitcell(1.0; SiteType=String)\naddsite!(unitcell, \"Spin\", FractCoord([0], [0.0]))\nlattice = make_lattice(unitcell, 8)\ntsymbed = translation_symmetry_embedding(lattice)\n\n#translation_group = TranslationGroup([Permutation([ mod(i, n_sites)+1 for i in 1:n_sites])])\nks = symmetry(tsymbed).fractional_momenta\n\nfor tsic in get_irrep_components(tsymbed)\n  k = ks[tsic.irrep_index]\n  hs_redrep = symmetry_reduce(hs_rep, tsic)\n  j1_redrep = represent(hs_redrep, j1)\n  j1_redrep_dense = Matrix(j1_redrep)   # Make a dense matrix\n  eigenvalues = eigvals(Hermitian(j1_redrep_dense))\n  println(\"E(k=\", join(string.(k), \",\"), \") : \", eigenvalues[1:5])\n  # scatter!(plt,\n  #          ones(size(eigenvalues)).*tsic.irrep_index, eigenvalues,\n  #          markershape=:hline,\n  #          markersize=10,\n  #          markerstrokecolor=:blue,\n  #          legend=:none)\nend\n# xticks!(plt, collect(0:n_sites), [\"All\", string.(1:n_sites)...])\n# xlims!(plt, -1, n_sites+1)\n# xlabel!(plt, \"Momentum index\")\n# ylabel!(plt, \"Energy\")\n# savefig(plt, \"spinchain.svg\"); nothing","category":"page"},{"location":"#QuantumHamiltonian","page":"Home","title":"QuantumHamiltonian","text":"","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"QuantumHamiltonian.jl is a tool for constructing quantum many-body Hamiltonians. It uses Abelian quantum numbers as well as translation symmetry to reduce dimensions of the Hilbert space and the corresponding matrix representation of the Hamiltonian.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A schematic for the structure of the package is the following:","category":"page"},{"location":"","page":"Home","title":"Home","text":"                State\n                  ↓\n                Site\n                  ↓\n                HilbertSpace                        Operator\n                  ↓                                   ↓\n                HilbertSpaceRepresentation        → OperatorRepresentation\n                  ↓                                   ↓\nSymmetryGroup → ReducedHilbertSpaceRepresentation → ReducedOperatorRepresentation","category":"page"},{"location":"","page":"Home","title":"Home","text":"The HilbertSpace, HilbertSpaceSector and Operator implement the abstract Hilbert spaces and operators, while the ...Representations implement the representations of the Hilbert spaces as 𝐂ⁿ (or 𝐑ⁿ), and of operators as n×n matrices.","category":"page"},{"location":"#Workflow","page":"Home","title":"Workflow","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"First you need to create a Hilbert space representation:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Define States, and Sites\nDefine a HilbertSpace\nDefine HilbertSpaceRepresentation and construct basis set. You can use quantum numbers to select only the basis states within a given sector or sectors.\nIf there is space symmetry, translation or point or both, use that to define ReducedHilbertSpaceRepresentation","category":"page"},{"location":"","page":"Home","title":"Home","text":"And then you can create operator representation using the Hilbert space representation from above:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Define Operators\nCreate OperatorRepresentation or ReducedOperatorRepresentation using HilbertSpaceRepresentation or ReducedHilbertSpaceRepresentation\nDepending on what is more efficient,","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"QuantumHamiltonian.jl is not yet registered on the Julia package registry. You can install it using its URL as","category":"page"},{"location":"","page":"Home","title":"Home","text":"]add https://github.com/kyungminlee/QuantumHamiltonian.jl.git","category":"page"},{"location":"","page":"Home","title":"Home","text":"Since, however, QuantumHamiltonian.jl depends on other packages including LatticeTools.jl, it is convenient to add a custom registry. In Julia, type","category":"page"},{"location":"","page":"Home","title":"Home","text":"]registry add https://github.com/kyungminlee/KyungminLeeRegistry.jl.git","category":"page"},{"location":"","page":"Home","title":"Home","text":"After this, you can","category":"page"},{"location":"","page":"Home","title":"Home","text":"]add QuantumHamiltonian","category":"page"}]
}
